# 作用域

作用域是指对某一属性（变量）或方法（函数）具有访问权限的代码空间。

**js中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里**

### 全局作用域（global scope）
在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：

1. 最外层函数和在最外层函数外面定义的变量拥有全局作用域
2. 所有为定义直接赋值的变量自动声明为拥有全局作用域
3. 所有window对象的属性拥有全局作用域
### 局部作用域（local scope）
局部作用域一般只在固定的代码片段内科访问到，最常见的例如函数的内部，因此一些地方也会看到有人把这种作用域成为函数作用域。
# 作用域链
在js中，一切都是对象。函数对象和其他对象一样，拥有可以通过代码访问的属性和一系列仅供js引擎访问的内部属性。
js列表的作用域实现：

>任何执行上下文时刻的作用域，都是由作用域链（scope chain）来实现。

>在一个函数被定义的时候，会将它定义时刻的scope chain链接到这个函数对象的[[scope]]属性。同时作用域链中会填入一个全局对象，该全局对象包含了所有全局变量。
>
![](http://pic002.cnblogs.com/images/2011/36987/2011090414435366.jpg)

>在一个函数对象被调用的时候，会创建一个活动对象（也就是一个对象），然后对每一个函数的形参，都命名为对象的命名属性，**然后将这个活动对象作为此时的作用域链（scope chain）最前端，并将这个函数对象的[[scope]]加入到scope chain中。**
>
>![](http://pic002.cnblogs.com/images/2011/36987/2011090414444843.jpg)

在调用函数执行之前创建的活动对象当中，其中所有的变量名和函数名都作为这个活动对象的同名属性，对于局部变量定义，变量的值会在真正执行的时候才计算，此时只是简单的赋值为undefined。

在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。
#作用域链和代码优化
从作用域链的结构可以看出，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应该尽量少使用全局变量，尽可能使用局部变量。**一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用：**
    
    funtion changeColor() {
        document.getElementById("btnChange").onclick = function() {
            document.getElementById("targetCavas").style.backgroundColor = "red";
        };
    }
这个函数引用了两次全局变量document，查找该变量必须遍历整个作用域链，知道最后在全局对象中才能找到。这段代码可以重写如下：

    function changeColor(){
        var doc = document;
        doc.getElementById("btnChange").onclick = function() {
            doc.getElementById("targetCanvas").style.backgroundColor = "red";
        };
    }

#改变作用域链
函数每次执行时对应的运行期上下文（运行期上下文是一个内部对象，在执行函数时创建，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，它的作用域链初始化为当前运行函数的[[scope]]所包含的对象。这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中，共同组成一个新的对象，也就是前面提到过的活动对象）都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联，一般情况下，在运行期上下文运行的过程中，其作用域链会只被with语句和catch语句影响。

with语句是对象的快捷应用方式，用来避免书写重复代码。

    function initUI(){
        with(document){
            var bd=body,
                links=getElementsByTagName("a"),
                i=0,
                len=links.length;
            while(i < len){
                update(links[i++]);
            }
            getElementById("btnInit").onclick=function(){
                doSomething();
            };
        }
    }
这里使用with语句来避免多次书写document，看上去更高效，实际上产生了性能问题。

当代码运行到with语句时，运行期上下文的作用域链临时被改变了，一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。因此在程序中应避免使用with语句，在这个例子中，只要简单的把document存储在一个局部变量中就可以提升性能。

![](http://pic002.cnblogs.com/images/2011/36987/2011090414454524.jpg)

另一个会改变作用域链的是try-catch语句中的catch语句。当try代码块中发生错误时，执行过程会跳转到catch语句，然后把异常对象推入一个可变对象并置于作用域的头部。在catch代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中。示例代码：
    
    try{
        doSomething();
    }catch(ex){
        alert(ex.message); //作用域链在此处改变
    }

一旦catch语句执行完毕，作用域链会返回到之前的状态。可以通过优化代码来减少catch语句对性能的影响，一个很好的模式是将错误委托给一个函数处理，例如：

    try{
        doSomething();
    }catch(ex){
        handleError(ex); //委托给处理器方法
    }
优化后的代码，handleError方法是catch子句中唯一执行的代码。该函数接受异常对象作为参数，这样可以更加灵活和统一的处理错误。由于只执行一条语句，且没有局部变量的访问，作用域链的临时改变就不会影响代码性能了。
# js的预编译

js是一种脚本语言，js的执行过程，是一种翻译执行的过程。

    <script>
        alert(typeof eve);         //function
        alert(typeof walle);       //undefined
        function eve() {           //函数定义式
            alert("I am Laruence");
        }
        var walle = function() {   //函数表达式
        }
        alert(typeof walle);       //function
    </script>

从例子中可以看出，在js中，是有预编译过程的，js在执行**每一段（js的预编译是以段为处理单元的)** js代码之前，都会首先处理var关键字和function定义式（函数定义式和函数表达式）

**对于函数定义式，会将函数定义提前，而函数表达式，会在执行过程中才计算**